# 多进程与多线程

<p align='center'>
<img src='https://github.com/w1991668899/blog/blob/master/image/go/多进程与多线程.jpg'>
</p>

参考：
- 《Go并发编程实战 第二版》
-  [Ardan labs](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
- [wiki百科](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B)

关于并行、并发、进程、线程的基本概念请[google](https://www.google.com.hk/)

# IPC方法分类

- **通信** 数据传输：管道(pipe)传递字节流、消息队列(message queue)传递结构化消息对象; 共享内存：共享内存区(是最快的一种IPC方式)
- **信号** 基于系统信号机制（异步方式）
- **同步** 信号量

**Go 支持IPC方式有管道、信号、socket**

# 进程

系统进行资源分配的最小单元

## CPU寄存器与程序计数器

- CPU寄存器：CPU内置极快内存
- CPU程序计数器：标记CPU正在或即将执行的下一条指令

每个子进程都源自其副进程的一个副本，它会获得父进程的一个副本，获取父进程的数据段、堆、栈的副本，并与父进程共享代码段。Linux系统基于写时复制提高创建进程的效率。

# 线程

系统进行调度的最小单位

## 线程模型

### 内核级线程模型

用户线程与KSE是1对1关系(1:1)。大部分编程语言的线程库都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个不同的KSE静态关联，因此其调度完全由OS调度器来做。这种方式实现简单，直接借助OS提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由OS层面亲自来做，在需要使用大量线程的场景下对OS的性能影响会很大。

### 用户线程模型

用户线程与KSE是多对1关系(M:1)，这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对OS内核透明，一个进程中所有创建的线程都与同一个KSE在运行时动态关联。现在有许多语言实现的 协程 基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。但该模型有个致命的缺点，如果我们在某个用户线程上调用阻塞式系统调用(如用阻塞方式read网络IO)，那么一旦KSE因阻塞被内核调度出CPU的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。 
所以这些语言的协程库会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。

### 两极线程模型

用户线程与KSE是多对多关系(M:N), 这种实现综合了前两种模型的优点，为一个进程中创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他KSE建立关联关系。当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。Go语言中的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的"线程"与KSE的动态关联。此模型有时也被称为 两级线程模型，即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度。

# 总结

Go 基于`M` `P` `G`(自行搜索，资料很丰富)的并发处理方式就是借鉴的两极线程模型<br><br>
Go 已经在操作系统级别将 IO-Bound 类型的工作转换为 CPU-Bound 类型。所有的上下文切换都是在应用程序级别进行的。在 Go 中，随着时间的推移，可以完成更多的工作，因为 Go 调度器尝试使用更少的线程，在每个线程上做更多的工作，这有助于减少操作系统和硬件的负载。



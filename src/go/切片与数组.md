# 关于slice与array

<p align='center'>
<img src='https://github.com/w1991668899/blog/blob/master/src/image/go/slice_array.jpeg'>
</p>



# 关于数组
每种编程语言中基本都会有数组类型, 大部分编程语言的数组下标都是从 0 开始，你想过这是为什么吗？

从数据结构与go中对数组的实现我们可以这样理解: **数组(array) 是一种线性数据结构，他是一组连续的内存空间，来存储一组具有相同类型的数据。**











上代码
```
func main() {
	arrayA := [2]int{666, 888}
	var arrayB [2]int

	arrayB = arrayA

	fmt.Printf("arrayA : %p , %v\n", &arrayA, arrayA)
	fmt.Printf("arrayB : %p , %v\n", &arrayB, arrayB)

	testArray(arrayA)
}

func testArray(x [2]int) {
	fmt.Printf("func Array : %p , %v\n", &x, x)
}

//arrayA : 0xc0000160b0 , [666 888]
//arrayB : 0xc0000160c0 , [666 888]
//func Array : 0xc000016100 , [666 888]    

```

可以看到上面三个地址都不同， Go 中数组赋值和函数传参都是值复制的

当传的是指针
```
func main() {
	arrayA := [2]int{666, 888}
	testArrayPoint(&arrayA)   // 传数组指针
	arrayB := arrayA[:]
	testSlicePoint(&arrayB)   // 传切片
	fmt.Printf("    arrayA : %p , %v\n", &arrayA, arrayA)
}

func testArrayPoint(x *[2]int) {
	fmt.Printf("func Array : %p , %v\n", x, *x)
	(*x)[1] += 111
}

func testSlicePoint(x *[]int)  {
	fmt.Printf("func Array : %p , %v\n", x, *x)
	(*x)[1] += 111
}

//func Array : 0xc0000160b0 , [666 888]
//func Array : 0xc00000a060 , [666 999]
//    arrayA : 0xc0000160b0 , [666 1110]

```

把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。但应考虑到对其他引用值的影响及底层数组的变化

参考书
- &laquo;Go 语言学习笔记&raquo;
- [go官网](https://golang.org/)
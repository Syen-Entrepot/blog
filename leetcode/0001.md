
# 题目地址-0001

https://leetcode-cn.com/problems/two-sum/

# 题目描述
```markdown
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```


# 方法一： 暴力法

## 思路

两个for循环中遍历每个元素，查找是否存在一个值与target-x 相等的目标元素

- rust

```rust
pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        for i in 0..nums.len() {
            for j in i+1..nums.len() {
                if target == nums[i] + nums[j] {
                    return vec![i as i32, j as i32];
                }
            }
        }
        vec![]
    }
```

- golang

```go
func twoSum(nums []int, target int) []int {
	for i := range nums {
		if i+1 < len(nums) {
			for j := range nums[i+1:] {
				if nums[i]+nums[j+i+1] == target {
					return []int{i, j + i + 1}
				}
			}
		}
	}
	return nil
}
```

## 复杂度分析

- 时间复杂度：O(n<sup>2</sup>)

- 空间复杂度：O(1)

# 方法二：两变哈希表

# 方法三： 一边哈希表

- rust
```rust

```

- golang

```go
func twoSum(nums []int, target int) []int {
    length := len(nums)
	m := make(map[int]int)
	res := make([]int, 0, 2)
	for i := 0; i < length; i++{
		m[nums[i]] = i
	}

	for i := 0; i < length; i++{
		comp := target - nums[i]
		if _, ok := m[comp]; ok && m[comp] != i{
			res = append(res, i, m[target-nums[i]])
			return res
		}
	}

	return res
}
```

# 方法四：二分查询

## 思路

- 对传入数据进行排序, sorted, 默认自小而大
- 定义两个下标 left right, 一个自小而大 一个自大而小
- while 循环 获取两个下标对应的value leftNum rightNum
- 如果leftNum + rightNum == target 满足条件 return 原数组的坐标 跳出循环
- 如果 > targer 则缩小下一个数据和 right -= 1
- 如果 < targer 则增大下一个数据和 left += 1